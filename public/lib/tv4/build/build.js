
/**
 * Require the given path.
 *
 * @param {String} path
 * @return {Object} exports
 * @api public
 */

function require(path, parent, orig) {
  var resolved = require.resolve(path);

  // lookup failed
  if (null == resolved) {
    orig = orig || path;
    parent = parent || 'root';
    var err = new Error('Failed to require "' + orig + '" from "' + parent + '"');
    err.path = orig;
    err.parent = parent;
    err.require = true;
    throw err;
  }

  var module = require.modules[resolved];

  // perform real require()
  // by invoking the module's
  // registered function
  if (!module.exports) {
    module.exports = {};
    module.client = module.component = true;
    module.call(this, module.exports, require.relative(resolved), module);
  }

  return module.exports;
}

/**
 * Registered modules.
 */

require.modules = {};

/**
 * Registered aliases.
 */

require.aliases = {};

/**
 * Resolve `path`.
 *
 * Lookup:
 *
 *   - PATH/index.js
 *   - PATH.js
 *   - PATH
 *
 * @param {String} path
 * @return {String} path or null
 * @api private
 */

require.resolve = function(path) {
  if (path.charAt(0) === '/') path = path.slice(1);

  var paths = [
    path,
    path + '.js',
    path + '.json',
    path + '/index.js',
    path + '/index.json'
  ];

  for (var i = 0; i < paths.length; i++) {
    var path = paths[i];
    if (require.modules.hasOwnProperty(path)) return path;
    if (require.aliases.hasOwnProperty(path)) return require.aliases[path];
  }
};

/**
 * Normalize `path` relative to the current path.
 *
 * @param {String} curr
 * @param {String} path
 * @return {String}
 * @api private
 */

require.normalize = function(curr, path) {
  var segs = [];

  if ('.' != path.charAt(0)) return path;

  curr = curr.split('/');
  path = path.split('/');

  for (var i = 0; i < path.length; ++i) {
    if ('..' == path[i]) {
      curr.pop();
    } else if ('.' != path[i] && '' != path[i]) {
      segs.push(path[i]);
    }
  }

  return curr.concat(segs).join('/');
};

/**
 * Register module at `path` with callback `definition`.
 *
 * @param {String} path
 * @param {Function} definition
 * @api private
 */

require.register = function(path, definition) {
  require.modules[path] = definition;
};

/**
 * Alias a module definition.
 *
 * @param {String} from
 * @param {String} to
 * @api private
 */

require.alias = function(from, to) {
  if (!require.modules.hasOwnProperty(from)) {
    throw new Error('Failed to alias "' + from + '", it does not exist');
  }
  require.aliases[to] = from;
};

/**
 * Return a require function relative to the `parent` path.
 *
 * @param {String} parent
 * @return {Function}
 * @api private
 */

require.relative = function(parent) {
  var p = require.normalize(parent, '..');

  /**
   * lastIndexOf helper.
   */

  function lastIndexOf(arr, obj) {
    var i = arr.length;
    while (i--) {
      if (arr[i] === obj) return i;
    }
    return -1;
  }

  /**
   * The relative require() itself.
   */

  function localRequire(path) {
    var resolved = localRequire.resolve(path);
    return require(resolved, parent, path);
  }

  /**
   * Resolve relative to the parent.
   */

  localRequire.resolve = function(path) {
    var c = path.charAt(0);
    if ('/' == c) return path.slice(1);
    if ('.' == c) return require.normalize(p, path);

    // resolve deps by returning
    // the dep in the nearest "deps"
    // directory
    var segs = parent.split('/');
    var i = lastIndexOf(segs, 'deps') + 1;
    if (!i) i = 0;
    path = segs.slice(0, i + 1).join('/') + '/deps/' + path;
    return path;
  };

  /**
   * Check if module is defined at `path`.
   */

  localRequire.exists = function(path) {
    return require.modules.hasOwnProperty(localRequire.resolve(path));
  };

  return localRequire;
};
require.register("tv4/lang/de.js", Function("exports, require, module",
"tv4.addLanguage('de',  {\n    INVALID_TYPE: \"Ungültiger Typ: {type} (erwartet wurde: {expected})\",\n    ENUM_MISMATCH: \"Keine Übereinstimmung mit der Aufzählung (enum) für: {value}\",\n    ANY_OF_MISSING: \"Daten stimmen nicht überein mit einem der Schemas von \\\"anyOf\\\"\",\n    ONE_OF_MISSING: \"Daten stimmen nicht überein mit einem der Schemas von \\\"oneOf\\\"\",\n    ONE_OF_MULTIPLE: \"Daten sind valid in Bezug auf mehreren Schemas von \\\"oneOf\\\": index {index1} und {index2}\",\n    NOT_PASSED: \"Daten stimmen mit dem \\\"not\\\" Schema überein\",\n    // Numeric errors\n    NUMBER_MULTIPLE_OF: \"Wert {value} ist kein Vielfaches von {multipleOf}\",\n    NUMBER_MINIMUM: \"Wert {value} ist kleiner als das Minimum {minimum}\",\n    NUMBER_MINIMUM_EXCLUSIVE: \"Wert {value} ist gleich dem Exklusiven Minimum {minimum}\",\n    NUMBER_MAXIMUM: \"Wert {value} ist größer als das Maximum {maximum}\",\n    NUMBER_MAXIMUM_EXCLUSIVE: \"Wert {value} ist gleich dem Exklusiven Maximum {maximum}\",\n    // String errors\n    STRING_LENGTH_SHORT: \"Zeichenkette zu kurz ({length} chars), minimum {minimum}\",\n    STRING_LENGTH_LONG: \"Zeichenkette zu lang ({length} chars), maximum {maximum}\",\n    STRING_PATTERN: \"Zeichenkette entspricht nicht dem Muster: {pattern}\",\n    // Object errors\n    OBJECT_PROPERTIES_MINIMUM: \"Zu wenige Attribute definiert ({propertyCount}), minimum {minimum}\",\n    OBJECT_PROPERTIES_MAXIMUM: \"Zu viele Attribute definiert ({propertyCount}), maximum {maximum}\",\n    OBJECT_REQUIRED: \"Notwendiges Attribut fehlt: {key}\",\n    OBJECT_ADDITIONAL_PROPERTIES: \"Zusätzliche Attribute nicht erlaubt\",\n    OBJECT_DEPENDENCY_KEY: \"Abhängigkeit fehlt - Schlüssel nicht vorhanden: {missing} (wegen Schlüssel: {key})\",\n    // Array errors\n    ARRAY_LENGTH_SHORT: \"Array zu kurz ({length}), minimum {minimum}\",\n    ARRAY_LENGTH_LONG: \"Array zu lang ({length}), maximum {maximum}\",\n    ARRAY_UNIQUE: \"Array Einträge nicht eindeutig (Index {match1} und {match2})\",\n    ARRAY_ADDITIONAL_ITEMS: \"Zusätzliche Einträge nicht erlaubt\"\n});\n//@ sourceURL=tv4/lang/de.js"
));
require.register("tv4/tv4.js", Function("exports, require, module",
"/*\nAuthor: Geraint Luff and others\nYear: 2013\n\nThis code is released into the \"public domain\" by its author(s).  Anybody may use, alter and distribute the code without restriction.  The author makes no guarantees, and takes no liability of any kind for use of this code.\n\nIf you find a bug or make an improvement, it would be courteous to let the author know, but it is not compulsory.\n*/\n(function (global) {\n'use strict';\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FObject%2Fkeys\nif (!Object.keys) {\n\tObject.keys = (function () {\n\t\tvar hasOwnProperty = Object.prototype.hasOwnProperty,\n\t\t\thasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),\n\t\t\tdontEnums = [\n\t\t\t\t'toString',\n\t\t\t\t'toLocaleString',\n\t\t\t\t'valueOf',\n\t\t\t\t'hasOwnProperty',\n\t\t\t\t'isPrototypeOf',\n\t\t\t\t'propertyIsEnumerable',\n\t\t\t\t'constructor'\n\t\t\t],\n\t\t\tdontEnumsLength = dontEnums.length;\n\n\t\treturn function (obj) {\n\t\t\tif (typeof obj !== 'object' && typeof obj !== 'function' || obj === null) {\n\t\t\t\tthrow new TypeError('Object.keys called on non-object');\n\t\t\t}\n\n\t\t\tvar result = [];\n\n\t\t\tfor (var prop in obj) {\n\t\t\t\tif (hasOwnProperty.call(obj, prop)) {\n\t\t\t\t\tresult.push(prop);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasDontEnumBug) {\n\t\t\t\tfor (var i=0; i < dontEnumsLength; i++) {\n\t\t\t\t\tif (hasOwnProperty.call(obj, dontEnums[i])) {\n\t\t\t\t\t\tresult.push(dontEnums[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t})();\n}\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\nif (!Object.create) {\n\tObject.create = (function(){\n\t\tfunction F(){}\n\n\t\treturn function(o){\n\t\t\tif (arguments.length !== 1) {\n\t\t\t\tthrow new Error('Object.create implementation only accepts one parameter.');\n\t\t\t}\n\t\t\tF.prototype = o;\n\t\t\treturn new F();\n\t\t};\n\t})();\n}\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FisArray\nif(!Array.isArray) {\n\tArray.isArray = function (vArg) {\n\t\treturn Object.prototype.toString.call(vArg) === \"[object Array]\";\n\t};\n}\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FindexOf\nif (!Array.prototype.indexOf) {\n\tArray.prototype.indexOf = function (searchElement /*, fromIndex */ ) {\n\t\tif (this === null) {\n\t\t\tthrow new TypeError();\n\t\t}\n\t\tvar t = Object(this);\n\t\tvar len = t.length >>> 0;\n\n\t\tif (len === 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tvar n = 0;\n\t\tif (arguments.length > 1) {\n\t\t\tn = Number(arguments[1]);\n\t\t\tif (n !== n) { // shortcut for verifying if it's NaN\n\t\t\t\tn = 0;\n\t\t\t} else if (n !== 0 && n !== Infinity && n !== -Infinity) {\n\t\t\t\tn = (n > 0 || -1) * Math.floor(Math.abs(n));\n\t\t\t}\n\t\t}\n\t\tif (n >= len) {\n\t\t\treturn -1;\n\t\t}\n\t\tvar k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\n\t\tfor (; k < len; k++) {\n\t\t\tif (k in t && t[k] === searchElement) {\n\t\t\t\treturn k;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t};\n}\n\n// Grungey Object.isFrozen hack\nif (!Object.isFrozen) {\n\tObject.isFrozen = function (obj) {\n\t\tvar key = \"tv4_test_frozen_key\";\n\t\twhile (obj.hasOwnProperty(key)) {\n\t\t\tkey += Math.random();\n\t\t}\n\t\ttry {\n\t\t\tobj[key] = true;\n\t\t\tdelete obj[key];\n\t\t\treturn false;\n\t\t} catch (e) {\n\t\t\treturn true;\n\t\t}\n\t};\n}\nvar ValidatorContext = function ValidatorContext(parent, collectMultiple, errorMessages, checkRecursive, trackUnknownProperties) {\n\tthis.missing = [];\n\tthis.missingMap = {};\n\tthis.formatValidators = parent ? Object.create(parent.formatValidators) : {};\n\tthis.schemas = parent ? Object.create(parent.schemas) : {};\n\tthis.collectMultiple = collectMultiple;\n\tthis.errors = [];\n\tthis.handleError = collectMultiple ? this.collectError : this.returnError;\n\tif (checkRecursive) {\n\t\tthis.checkRecursive = true;\n\t\tthis.scanned = [];\n\t\tthis.scannedFrozen = [];\n\t\tthis.scannedFrozenSchemas = [];\n\t\tthis.key = 'tv4_validation_id';\n\t}\n\tif (trackUnknownProperties) {\n\t\tthis.trackUnknownProperties = true;\n\t\tthis.knownPropertyPaths = {};\n\t\tthis.unknownPropertyPaths = {};\n\t}\n\tthis.errorMessages = errorMessages;\n};\nValidatorContext.prototype.createError = function (code, messageParams, dataPath, schemaPath, subErrors) {\n\tvar messageTemplate = this.errorMessages[code] || ErrorMessagesDefault[code];\n\tif (typeof messageTemplate !== 'string') {\n\t\treturn new ValidationError(code, \"Unknown error code \" + code + \": \" + JSON.stringify(messageParams), dataPath, schemaPath, subErrors);\n\t}\n\t// Adapted from Crockford's supplant()\n\tvar message = messageTemplate.replace(/\\{([^{}]*)\\}/g, function (whole, varName) {\n\t\tvar subValue = messageParams[varName];\n\t\treturn typeof subValue === 'string' || typeof subValue === 'number' ? subValue : whole;\n\t});\n\treturn new ValidationError(code, message, dataPath, schemaPath, subErrors);\n};\nValidatorContext.prototype.returnError = function (error) {\n\treturn error;\n};\nValidatorContext.prototype.collectError = function (error) {\n\tif (error) {\n\t\tthis.errors.push(error);\n\t}\n\treturn null;\n};\nValidatorContext.prototype.prefixErrors = function (startIndex, dataPath, schemaPath) {\n\tfor (var i = startIndex; i < this.errors.length; i++) {\n\t\tthis.errors[i] = this.errors[i].prefixWith(dataPath, schemaPath);\n\t}\n\treturn this;\n};\nValidatorContext.prototype.banUnknownProperties = function () {\n\tfor (var unknownPath in this.unknownPropertyPaths) {\n\t\tvar error = this.createError(ErrorCodes.UNKNOWN_PROPERTY, {path: unknownPath}, unknownPath, \"\");\n\t\tvar result = this.handleError(error);\n\t\tif (result) {\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.addFormat = function (format, validator) {\n\tif (typeof format === 'object') {\n\t\tfor (var key in format) {\n\t\t\tthis.addFormat(key, format[key]);\n\t\t}\n\t\treturn this;\n\t}\n\tthis.formatValidators[format] = validator;\n};\nValidatorContext.prototype.resolveRefs = function (schema, urlHistory) {\n\tif (schema['$ref'] !== undefined) {\n\t\turlHistory = urlHistory || {};\n\t\tif (urlHistory[schema['$ref']]) {\n\t\t\treturn this.createError(ErrorCodes.CIRCULAR_REFERENCE, {urls: Object.keys(urlHistory).join(', ')}, '', '');\n\t\t}\n\t\turlHistory[schema['$ref']] = true;\n\t\tschema = this.getSchema(schema['$ref'], urlHistory);\n\t}\n\treturn schema;\n};\nValidatorContext.prototype.getSchema = function (url, urlHistory) {\n\tvar schema;\n\tif (this.schemas[url] !== undefined) {\n\t\tschema = this.schemas[url];\n\t\treturn this.resolveRefs(schema, urlHistory);\n\t}\n\tvar baseUrl = url;\n\tvar fragment = \"\";\n\tif (url.indexOf('#') !== -1) {\n\t\tfragment = url.substring(url.indexOf(\"#\") + 1);\n\t\tbaseUrl = url.substring(0, url.indexOf(\"#\"));\n\t}\n\tif (typeof this.schemas[baseUrl] === 'object') {\n\t\tschema = this.schemas[baseUrl];\n\t\tvar pointerPath = decodeURIComponent(fragment);\n\t\tif (pointerPath === \"\") {\n\t\t\treturn this.resolveRefs(schema, urlHistory);\n\t\t} else if (pointerPath.charAt(0) !== \"/\") {\n\t\t\treturn undefined;\n\t\t}\n\t\tvar parts = pointerPath.split(\"/\").slice(1);\n\t\tfor (var i = 0; i < parts.length; i++) {\n\t\t\tvar component = parts[i].replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n\t\t\tif (schema[component] === undefined) {\n\t\t\t\tschema = undefined;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tschema = schema[component];\n\t\t}\n\t\tif (schema !== undefined) {\n\t\t\treturn this.resolveRefs(schema, urlHistory);\n\t\t}\n\t}\n\tif (this.missing[baseUrl] === undefined) {\n\t\tthis.missing.push(baseUrl);\n\t\tthis.missing[baseUrl] = baseUrl;\n\t\tthis.missingMap[baseUrl] = baseUrl;\n\t}\n};\nValidatorContext.prototype.searchSchemas = function (schema, url) {\n\tif (typeof schema.id === \"string\") {\n\t\tif (isTrustedUrl(url, schema.id)) {\n\t\t\tif (this.schemas[schema.id] === undefined) {\n\t\t\t\tthis.schemas[schema.id] = schema;\n\t\t\t}\n\t\t}\n\t}\n\tif (typeof schema === \"object\") {\n\t\tfor (var key in schema) {\n\t\t\tif (key !== \"enum\") {\n\t\t\t\tif (typeof schema[key] === \"object\") {\n\t\t\t\t\tthis.searchSchemas(schema[key], url);\n\t\t\t\t} else if (key === \"$ref\") {\n\t\t\t\t\tvar uri = getDocumentUri(schema[key]);\n\t\t\t\t\tif (uri && this.schemas[uri] === undefined && this.missingMap[uri] === undefined) {\n\t\t\t\t\t\tthis.missingMap[uri] = uri;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\nValidatorContext.prototype.addSchema = function (url, schema) {\n\t//overload\n\tif (typeof schema === 'undefined') {\n\t\tif (typeof url === 'object' && typeof url.id === 'string') {\n\t\t\tschema = url;\n\t\t\turl = schema.id;\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (url = getDocumentUri(url) + \"#\") {\n\t\t// Remove empty fragment\n\t\turl = getDocumentUri(url);\n\t}\n\tthis.schemas[url] = schema;\n\tdelete this.missingMap[url];\n\tnormSchema(schema, url);\n\tthis.searchSchemas(schema, url);\n};\n\nValidatorContext.prototype.getSchemaMap = function () {\n\tvar map = {};\n\tfor (var key in this.schemas) {\n\t\tmap[key] = this.schemas[key];\n\t}\n\treturn map;\n};\n\nValidatorContext.prototype.getSchemaUris = function (filterRegExp) {\n\tvar list = [];\n\tfor (var key in this.schemas) {\n\t\tif (!filterRegExp || filterRegExp.test(key)) {\n\t\t\tlist.push(key);\n\t\t}\n\t}\n\treturn list;\n};\n\nValidatorContext.prototype.getMissingUris = function (filterRegExp) {\n\tvar list = [];\n\tfor (var key in this.missingMap) {\n\t\tif (!filterRegExp || filterRegExp.test(key)) {\n\t\t\tlist.push(key);\n\t\t}\n\t}\n\treturn list;\n};\n\nValidatorContext.prototype.dropSchemas = function () {\n\tthis.schemas = {};\n\tthis.reset();\n};\nValidatorContext.prototype.reset = function () {\n\tthis.missing = [];\n\tthis.missingMap = {};\n\tthis.errors = [];\n};\n\nValidatorContext.prototype.validateAll = function (data, schema, dataPathParts, schemaPathParts, dataPointerPath) {\n\tvar topLevel;\n\tschema = this.resolveRefs(schema);\n\tif (!schema) {\n\t\treturn null;\n\t} else if (schema instanceof ValidationError) {\n\t\tthis.errors.push(schema);\n\t\treturn schema;\n\t}\n\n\tif (this.checkRecursive && (typeof data) === 'object') {\n\t\ttopLevel = !this.scanned.length;\n\t\tif (data[this.key] && data[this.key].indexOf(schema) !== -1) { return null; }\n\t\tvar frozenIndex;\n\t\tif (Object.isFrozen(data)) {\n\t\t\tfrozenIndex = this.scannedFrozen.indexOf(data);\n\t\t\tif (frozenIndex !== -1 && this.scannedFrozenSchemas[frozenIndex].indexOf(schema) !== -1) { return null; }\n\t\t}\n\t\tthis.scanned.push(data);\n\t\tif (Object.isFrozen(data)) {\n\t\t\tif (frozenIndex === -1) {\n\t\t\t\tfrozenIndex = this.scannedFrozen.length;\n\t\t\t\tthis.scannedFrozen.push(data);\n\t\t\t\tthis.scannedFrozenSchemas.push([]);\n\t\t\t}\n\t\t\tthis.scannedFrozenSchemas[frozenIndex].push(schema);\n\t\t} else {\n\t\t\tif (!data[this.key]) {\n\t\t\t\ttry {\n\t\t\t\t\tObject.defineProperty(data, this.key, {\n\t\t\t\t\t\tvalue: [],\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t});\n\t\t\t\t} catch (e) {\n\t\t\t\t\t//IE 7/8 workaround\n\t\t\t\t\tdata[this.key] = [];\n\t\t\t\t}\n\t\t\t}\n\t\t\tdata[this.key].push(schema);\n\t\t}\n\t}\n\n\tvar errorCount = this.errors.length;\n\tvar error = this.validateBasic(data, schema, dataPointerPath)\n\t\t|| this.validateNumeric(data, schema, dataPointerPath)\n\t\t|| this.validateString(data, schema, dataPointerPath)\n\t\t|| this.validateArray(data, schema, dataPointerPath)\n\t\t|| this.validateObject(data, schema, dataPointerPath)\n\t\t|| this.validateCombinations(data, schema, dataPointerPath)\n\t\t|| this.validateFormat(data, schema, dataPointerPath)\n\t\t|| null;\n\n\tif (topLevel) {\n\t\twhile (this.scanned.length) {\n\t\t\tvar item = this.scanned.pop();\n\t\t\tdelete item[this.key];\n\t\t}\n\t\tthis.scannedFrozen = [];\n\t\tthis.scannedFrozenSchemas = [];\n\t}\n\n\tif (error || errorCount !== this.errors.length) {\n\t\twhile ((dataPathParts && dataPathParts.length) || (schemaPathParts && schemaPathParts.length)) {\n\t\t\tvar dataPart = (dataPathParts && dataPathParts.length) ? \"\" + dataPathParts.pop() : null;\n\t\t\tvar schemaPart = (schemaPathParts && schemaPathParts.length) ? \"\" + schemaPathParts.pop() : null;\n\t\t\tif (error) {\n\t\t\t\terror = error.prefixWith(dataPart, schemaPart);\n\t\t\t}\n\t\t\tthis.prefixErrors(errorCount, dataPart, schemaPart);\n\t\t}\n\t}\n\n\treturn this.handleError(error);\n};\nValidatorContext.prototype.validateFormat = function (data, schema) {\n\tif (typeof schema.format !== 'string' || !this.formatValidators[schema.format]) {\n\t\treturn null;\n\t}\n\tvar errorMessage = this.formatValidators[schema.format].call(null, data, schema);\n\tif (typeof errorMessage === 'string' || typeof errorMessage === 'number') {\n\t\treturn this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage}).prefixWith(null, \"format\");\n\t} else if (errorMessage && typeof errorMessage === 'object') {\n\t\treturn this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage.message || \"?\"}, errorMessage.dataPath || null, errorMessage.schemaPath || \"/format\");\n\t}\n\treturn null;\n};\n\nfunction recursiveCompare(A, B) {\n\tif (A === B) {\n\t\treturn true;\n\t}\n\tif (A && B && typeof A === \"object\" && typeof B === \"object\") {\n\t\tif (Array.isArray(A) !== Array.isArray(B)) {\n\t\t\treturn false;\n\t\t} else if (Array.isArray(A)) {\n\t\t\tif (A.length !== B.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (var i = 0; i < A.length; i++) {\n\t\t\t\tif (!recursiveCompare(A[i], B[i])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvar key;\n\t\t\tfor (key in A) {\n\t\t\t\tif (B[key] === undefined && A[key] !== undefined) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (key in B) {\n\t\t\t\tif (A[key] === undefined && B[key] !== undefined) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (key in A) {\n\t\t\t\tif (!recursiveCompare(A[key], B[key])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nValidatorContext.prototype.validateBasic = function validateBasic(data, schema, dataPointerPath) {\n\tvar error;\n\tif (error = this.validateType(data, schema, dataPointerPath)) {\n\t\treturn error.prefixWith(null, \"type\");\n\t}\n\tif (error = this.validateEnum(data, schema, dataPointerPath)) {\n\t\treturn error.prefixWith(null, \"type\");\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateType = function validateType(data, schema) {\n\tif (schema.type === undefined) {\n\t\treturn null;\n\t}\n\tvar dataType = typeof data;\n\tif (data === null) {\n\t\tdataType = \"null\";\n\t} else if (Array.isArray(data)) {\n\t\tdataType = \"array\";\n\t}\n\tvar allowedTypes = schema.type;\n\tif (typeof allowedTypes !== \"object\") {\n\t\tallowedTypes = [allowedTypes];\n\t}\n\n\tfor (var i = 0; i < allowedTypes.length; i++) {\n\t\tvar type = allowedTypes[i];\n\t\tif (type === dataType || (type === \"integer\" && dataType === \"number\" && (data % 1 === 0))) {\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn this.createError(ErrorCodes.INVALID_TYPE, {type: dataType, expected: allowedTypes.join(\"/\")});\n};\n\nValidatorContext.prototype.validateEnum = function validateEnum(data, schema) {\n\tif (schema[\"enum\"] === undefined) {\n\t\treturn null;\n\t}\n\tfor (var i = 0; i < schema[\"enum\"].length; i++) {\n\t\tvar enumVal = schema[\"enum\"][i];\n\t\tif (recursiveCompare(data, enumVal)) {\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn this.createError(ErrorCodes.ENUM_MISMATCH, {value: (typeof JSON !== 'undefined') ? JSON.stringify(data) : data});\n};\n\nValidatorContext.prototype.validateNumeric = function validateNumeric(data, schema, dataPointerPath) {\n\treturn this.validateMultipleOf(data, schema, dataPointerPath)\n\t\t|| this.validateMinMax(data, schema, dataPointerPath)\n\t\t|| null;\n};\n\nValidatorContext.prototype.validateMultipleOf = function validateMultipleOf(data, schema) {\n\tvar multipleOf = schema.multipleOf || schema.divisibleBy;\n\tif (multipleOf === undefined) {\n\t\treturn null;\n\t}\n\tif (typeof data === \"number\") {\n\t\tif ((data/multipleOf)%1 !== 0) { // *slightly* less prone to floating-point errors than a simple modulo, for some reason?\n\t\t\treturn this.createError(ErrorCodes.NUMBER_MULTIPLE_OF, {value: data, multipleOf: multipleOf});\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateMinMax = function validateMinMax(data, schema) {\n\tif (typeof data !== \"number\") {\n\t\treturn null;\n\t}\n\tif (schema.minimum !== undefined) {\n\t\tif (data < schema.minimum) {\n\t\t\treturn this.createError(ErrorCodes.NUMBER_MINIMUM, {value: data, minimum: schema.minimum}).prefixWith(null, \"minimum\");\n\t\t}\n\t\tif (schema.exclusiveMinimum && data === schema.minimum) {\n\t\t\treturn this.createError(ErrorCodes.NUMBER_MINIMUM_EXCLUSIVE, {value: data, minimum: schema.minimum}).prefixWith(null, \"exclusiveMinimum\");\n\t\t}\n\t}\n\tif (schema.maximum !== undefined) {\n\t\tif (data > schema.maximum) {\n\t\t\treturn this.createError(ErrorCodes.NUMBER_MAXIMUM, {value: data, maximum: schema.maximum}).prefixWith(null, \"maximum\");\n\t\t}\n\t\tif (schema.exclusiveMaximum && data === schema.maximum) {\n\t\t\treturn this.createError(ErrorCodes.NUMBER_MAXIMUM_EXCLUSIVE, {value: data, maximum: schema.maximum}).prefixWith(null, \"exclusiveMaximum\");\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateString = function validateString(data, schema, dataPointerPath) {\n\treturn this.validateStringLength(data, schema, dataPointerPath)\n\t\t|| this.validateStringPattern(data, schema, dataPointerPath)\n\t\t|| null;\n};\n\nValidatorContext.prototype.validateStringLength = function validateStringLength(data, schema) {\n\tif (typeof data !== \"string\") {\n\t\treturn null;\n\t}\n\tif (schema.minLength !== undefined) {\n\t\tif (data.length < schema.minLength) {\n\t\t\treturn this.createError(ErrorCodes.STRING_LENGTH_SHORT, {length: data.length, minimum: schema.minLength}).prefixWith(null, \"minLength\");\n\t\t}\n\t}\n\tif (schema.maxLength !== undefined) {\n\t\tif (data.length > schema.maxLength) {\n\t\t\treturn this.createError(ErrorCodes.STRING_LENGTH_LONG, {length: data.length, maximum: schema.maxLength}).prefixWith(null, \"maxLength\");\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateStringPattern = function validateStringPattern(data, schema) {\n\tif (typeof data !== \"string\" || schema.pattern === undefined) {\n\t\treturn null;\n\t}\n\tvar regexp = new RegExp(schema.pattern);\n\tif (!regexp.test(data)) {\n\t\treturn this.createError(ErrorCodes.STRING_PATTERN, {pattern: schema.pattern}).prefixWith(null, \"pattern\");\n\t}\n\treturn null;\n};\nValidatorContext.prototype.validateArray = function validateArray(data, schema, dataPointerPath) {\n\tif (!Array.isArray(data)) {\n\t\treturn null;\n\t}\n\treturn this.validateArrayLength(data, schema, dataPointerPath)\n\t\t|| this.validateArrayUniqueItems(data, schema, dataPointerPath)\n\t\t|| this.validateArrayItems(data, schema, dataPointerPath)\n\t\t|| null;\n};\n\nValidatorContext.prototype.validateArrayLength = function validateArrayLength(data, schema) {\n\tvar error;\n\tif (schema.minItems !== undefined) {\n\t\tif (data.length < schema.minItems) {\n\t\t\terror = (this.createError(ErrorCodes.ARRAY_LENGTH_SHORT, {length: data.length, minimum: schema.minItems})).prefixWith(null, \"minItems\");\n\t\t\tif (this.handleError(error)) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t}\n\tif (schema.maxItems !== undefined) {\n\t\tif (data.length > schema.maxItems) {\n\t\t\terror = (this.createError(ErrorCodes.ARRAY_LENGTH_LONG, {length: data.length, maximum: schema.maxItems})).prefixWith(null, \"maxItems\");\n\t\t\tif (this.handleError(error)) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateArrayUniqueItems = function validateArrayUniqueItems(data, schema) {\n\tif (schema.uniqueItems) {\n\t\tfor (var i = 0; i < data.length; i++) {\n\t\t\tfor (var j = i + 1; j < data.length; j++) {\n\t\t\t\tif (recursiveCompare(data[i], data[j])) {\n\t\t\t\t\tvar error = (this.createError(ErrorCodes.ARRAY_UNIQUE, {match1: i, match2: j})).prefixWith(null, \"uniqueItems\");\n\t\t\t\t\tif (this.handleError(error)) {\n\t\t\t\t\t\treturn error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateArrayItems = function validateArrayItems(data, schema, dataPointerPath) {\n\tif (schema.items === undefined) {\n\t\treturn null;\n\t}\n\tvar error, i;\n\tif (Array.isArray(schema.items)) {\n\t\tfor (i = 0; i < data.length; i++) {\n\t\t\tif (i < schema.items.length) {\n\t\t\t\tif (error = this.validateAll(data[i], schema.items[i], [i], [\"items\", i], dataPointerPath + \"/\" + i)) {\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t} else if (schema.additionalItems !== undefined) {\n\t\t\t\tif (typeof schema.additionalItems === \"boolean\") {\n\t\t\t\t\tif (!schema.additionalItems) {\n\t\t\t\t\t\terror = (this.createError(ErrorCodes.ARRAY_ADDITIONAL_ITEMS, {})).prefixWith(\"\" + i, \"additionalItems\");\n\t\t\t\t\t\tif (this.handleError(error)) {\n\t\t\t\t\t\t\treturn error;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (error = this.validateAll(data[i], schema.additionalItems, [i], [\"additionalItems\"], dataPointerPath + \"/\" + i)) {\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < data.length; i++) {\n\t\t\tif (error = this.validateAll(data[i], schema.items, [i], [\"items\"], dataPointerPath + \"/\" + i)) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateObject = function validateObject(data, schema, dataPointerPath) {\n\tif (typeof data !== \"object\" || data === null || Array.isArray(data)) {\n\t\treturn null;\n\t}\n\treturn this.validateObjectMinMaxProperties(data, schema, dataPointerPath)\n\t\t|| this.validateObjectRequiredProperties(data, schema, dataPointerPath)\n\t\t|| this.validateObjectProperties(data, schema, dataPointerPath)\n\t\t|| this.validateObjectDependencies(data, schema, dataPointerPath)\n\t\t|| null;\n};\n\nValidatorContext.prototype.validateObjectMinMaxProperties = function validateObjectMinMaxProperties(data, schema) {\n\tvar keys = Object.keys(data);\n\tvar error;\n\tif (schema.minProperties !== undefined) {\n\t\tif (keys.length < schema.minProperties) {\n\t\t\terror = this.createError(ErrorCodes.OBJECT_PROPERTIES_MINIMUM, {propertyCount: keys.length, minimum: schema.minProperties}).prefixWith(null, \"minProperties\");\n\t\t\tif (this.handleError(error)) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t}\n\tif (schema.maxProperties !== undefined) {\n\t\tif (keys.length > schema.maxProperties) {\n\t\t\terror = this.createError(ErrorCodes.OBJECT_PROPERTIES_MAXIMUM, {propertyCount: keys.length, maximum: schema.maxProperties}).prefixWith(null, \"maxProperties\");\n\t\t\tif (this.handleError(error)) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateObjectRequiredProperties = function validateObjectRequiredProperties(data, schema) {\n\tif (schema.required !== undefined) {\n\t\tfor (var i = 0; i < schema.required.length; i++) {\n\t\t\tvar key = schema.required[i];\n\t\t\tif (data[key] === undefined) {\n\t\t\t\tvar error = this.createError(ErrorCodes.OBJECT_REQUIRED, {key: key}).prefixWith(null, \"\" + i).prefixWith(null, \"required\");\n\t\t\t\tif (this.handleError(error)) {\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateObjectProperties = function validateObjectProperties(data, schema, dataPointerPath) {\n\tvar error;\n\tfor (var key in data) {\n\t\tvar keyPointerPath = dataPointerPath + \"/\" + key.replace(/~/g, '~0').replace(/\\//g, '~1');\n\t\tvar foundMatch = false;\n\t\tif (schema.properties !== undefined && schema.properties[key] !== undefined) {\n\t\t\tfoundMatch = true;\n\t\t\tif (error = this.validateAll(data[key], schema.properties[key], [key], [\"properties\", key], keyPointerPath)) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\tif (schema.patternProperties !== undefined) {\n\t\t\tfor (var patternKey in schema.patternProperties) {\n\t\t\t\tvar regexp = new RegExp(patternKey);\n\t\t\t\tif (regexp.test(key)) {\n\t\t\t\t\tfoundMatch = true;\n\t\t\t\t\tif (error = this.validateAll(data[key], schema.patternProperties[patternKey], [key], [\"patternProperties\", patternKey], keyPointerPath)) {\n\t\t\t\t\t\treturn error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!foundMatch) {\n\t\t\tif (schema.additionalProperties !== undefined) {\n\t\t\t\tif (this.trackUnknownProperties) {\n\t\t\t\t\tthis.knownPropertyPaths[keyPointerPath] = true;\n\t\t\t\t\tdelete this.unknownPropertyPaths[keyPointerPath];\n\t\t\t\t}\n\t\t\t\tif (typeof schema.additionalProperties === \"boolean\") {\n\t\t\t\t\tif (!schema.additionalProperties) {\n\t\t\t\t\t\terror = this.createError(ErrorCodes.OBJECT_ADDITIONAL_PROPERTIES, {}).prefixWith(key, \"additionalProperties\");\n\t\t\t\t\t\tif (this.handleError(error)) {\n\t\t\t\t\t\t\treturn error;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (error = this.validateAll(data[key], schema.additionalProperties, [key], [\"additionalProperties\"], keyPointerPath)) {\n\t\t\t\t\t\treturn error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (this.trackUnknownProperties && !this.knownPropertyPaths[keyPointerPath]) {\n\t\t\t\tthis.unknownPropertyPaths[keyPointerPath] = true;\n\t\t\t}\n\t\t} else if (this.trackUnknownProperties) {\n\t\t\tthis.knownPropertyPaths[keyPointerPath] = true;\n\t\t\tdelete this.unknownPropertyPaths[keyPointerPath];\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateObjectDependencies = function validateObjectDependencies(data, schema, dataPointerPath) {\n\tvar error;\n\tif (schema.dependencies !== undefined) {\n\t\tfor (var depKey in schema.dependencies) {\n\t\t\tif (data[depKey] !== undefined) {\n\t\t\t\tvar dep = schema.dependencies[depKey];\n\t\t\t\tif (typeof dep === \"string\") {\n\t\t\t\t\tif (data[dep] === undefined) {\n\t\t\t\t\t\terror = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {key: depKey, missing: dep}).prefixWith(null, depKey).prefixWith(null, \"dependencies\");\n\t\t\t\t\t\tif (this.handleError(error)) {\n\t\t\t\t\t\t\treturn error;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (Array.isArray(dep)) {\n\t\t\t\t\tfor (var i = 0; i < dep.length; i++) {\n\t\t\t\t\t\tvar requiredKey = dep[i];\n\t\t\t\t\t\tif (data[requiredKey] === undefined) {\n\t\t\t\t\t\t\terror = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {key: depKey, missing: requiredKey}).prefixWith(null, \"\" + i).prefixWith(null, depKey).prefixWith(null, \"dependencies\");\n\t\t\t\t\t\t\tif (this.handleError(error)) {\n\t\t\t\t\t\t\t\treturn error;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (error = this.validateAll(data, dep, [], [\"dependencies\", depKey], dataPointerPath)) {\n\t\t\t\t\t\treturn error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateCombinations = function validateCombinations(data, schema, dataPointerPath) {\n\treturn this.validateAllOf(data, schema, dataPointerPath)\n\t\t|| this.validateAnyOf(data, schema, dataPointerPath)\n\t\t|| this.validateOneOf(data, schema, dataPointerPath)\n\t\t|| this.validateNot(data, schema, dataPointerPath)\n\t\t|| null;\n};\n\nValidatorContext.prototype.validateAllOf = function validateAllOf(data, schema, dataPointerPath) {\n\tif (schema.allOf === undefined) {\n\t\treturn null;\n\t}\n\tvar error;\n\tfor (var i = 0; i < schema.allOf.length; i++) {\n\t\tvar subSchema = schema.allOf[i];\n\t\tif (error = this.validateAll(data, subSchema, [], [\"allOf\", i], dataPointerPath)) {\n\t\t\treturn error;\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateAnyOf = function validateAnyOf(data, schema, dataPointerPath) {\n\tif (schema.anyOf === undefined) {\n\t\treturn null;\n\t}\n\tvar errors = [];\n\tvar startErrorCount = this.errors.length;\n\tvar oldUnknownPropertyPaths, oldKnownPropertyPaths;\n\tif (this.trackUnknownProperties) {\n\t\toldUnknownPropertyPaths = this.unknownPropertyPaths;\n\t\toldKnownPropertyPaths = this.knownPropertyPaths;\n\t}\n\tvar errorAtEnd = true;\n\tfor (var i = 0; i < schema.anyOf.length; i++) {\n\t\tif (this.trackUnknownProperties) {\n\t\t\tthis.unknownPropertyPaths = {};\n\t\t\tthis.knownPropertyPaths = {};\n\t\t}\n\t\tvar subSchema = schema.anyOf[i];\n\n\t\tvar errorCount = this.errors.length;\n\t\tvar error = this.validateAll(data, subSchema, [], [\"anyOf\", i], dataPointerPath);\n\n\t\tif (error === null && errorCount === this.errors.length) {\n\t\t\tthis.errors = this.errors.slice(0, startErrorCount);\n\n\t\t\tif (this.trackUnknownProperties) {\n\t\t\t\tfor (var knownKey in this.knownPropertyPaths) {\n\t\t\t\t\toldKnownPropertyPaths[knownKey] = true;\n\t\t\t\t\tdelete oldUnknownPropertyPaths[knownKey];\n\t\t\t\t}\n\t\t\t\tfor (var unknownKey in this.unknownPropertyPaths) {\n\t\t\t\t\tif (!oldKnownPropertyPaths[unknownKey]) {\n\t\t\t\t\t\toldUnknownPropertyPaths[unknownKey] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// We need to continue looping so we catch all the property definitions, but we don't want to return an error\n\t\t\t\terrorAtEnd = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t\tif (error) {\n\t\t\terrors.push(error.prefixWith(null, \"\" + i).prefixWith(null, \"anyOf\"));\n\t\t}\n\t}\n\tif (this.trackUnknownProperties) {\n\t\tthis.unknownPropertyPaths = oldUnknownPropertyPaths;\n\t\tthis.knownPropertyPaths = oldKnownPropertyPaths;\n\t}\n\tif (errorAtEnd) {\n\t\terrors = errors.concat(this.errors.slice(startErrorCount));\n\t\tthis.errors = this.errors.slice(0, startErrorCount);\n\t\treturn this.createError(ErrorCodes.ANY_OF_MISSING, {}, \"\", \"/anyOf\", errors);\n\t}\n};\n\nValidatorContext.prototype.validateOneOf = function validateOneOf(data, schema, dataPointerPath) {\n\tif (schema.oneOf === undefined) {\n\t\treturn null;\n\t}\n\tvar validIndex = null;\n\tvar errors = [];\n\tvar startErrorCount = this.errors.length;\n\tvar oldUnknownPropertyPaths, oldKnownPropertyPaths;\n\tif (this.trackUnknownProperties) {\n\t\toldUnknownPropertyPaths = this.unknownPropertyPaths;\n\t\toldKnownPropertyPaths = this.knownPropertyPaths;\n\t}\n\tfor (var i = 0; i < schema.oneOf.length; i++) {\n\t\tif (this.trackUnknownProperties) {\n\t\t\tthis.unknownPropertyPaths = {};\n\t\t\tthis.knownPropertyPaths = {};\n\t\t}\n\t\tvar subSchema = schema.oneOf[i];\n\n\t\tvar errorCount = this.errors.length;\n\t\tvar error = this.validateAll(data, subSchema, [], [\"oneOf\", i], dataPointerPath);\n\n\t\tif (error === null && errorCount === this.errors.length) {\n\t\t\tif (validIndex === null) {\n\t\t\t\tvalidIndex = i;\n\t\t\t} else {\n\t\t\t\tthis.errors = this.errors.slice(0, startErrorCount);\n\t\t\t\treturn this.createError(ErrorCodes.ONE_OF_MULTIPLE, {index1: validIndex, index2: i}, \"\", \"/oneOf\");\n\t\t\t}\n\t\t\tif (this.trackUnknownProperties) {\n\t\t\t\tfor (var knownKey in this.knownPropertyPaths) {\n\t\t\t\t\toldKnownPropertyPaths[knownKey] = true;\n\t\t\t\t\tdelete oldUnknownPropertyPaths[knownKey];\n\t\t\t\t}\n\t\t\t\tfor (var unknownKey in this.unknownPropertyPaths) {\n\t\t\t\t\tif (!oldKnownPropertyPaths[unknownKey]) {\n\t\t\t\t\t\toldUnknownPropertyPaths[unknownKey] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (error) {\n\t\t\terrors.push(error.prefixWith(null, \"\" + i).prefixWith(null, \"oneOf\"));\n\t\t}\n\t}\n\tif (this.trackUnknownProperties) {\n\t\tthis.unknownPropertyPaths = oldUnknownPropertyPaths;\n\t\tthis.knownPropertyPaths = oldKnownPropertyPaths;\n\t}\n\tif (validIndex === null) {\n\t\terrors = errors.concat(this.errors.slice(startErrorCount));\n\t\tthis.errors = this.errors.slice(0, startErrorCount);\n\t\treturn this.createError(ErrorCodes.ONE_OF_MISSING, {}, \"\", \"/oneOf\", errors);\n\t} else {\n\t\tthis.errors = this.errors.slice(0, startErrorCount);\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateNot = function validateNot(data, schema, dataPointerPath) {\n\tif (schema.not === undefined) {\n\t\treturn null;\n\t}\n\tvar oldErrorCount = this.errors.length;\n\tvar oldUnknownPropertyPaths, oldKnownPropertyPaths;\n\tif (this.trackUnknownProperties) {\n\t\toldUnknownPropertyPaths = this.unknownPropertyPaths;\n\t\toldKnownPropertyPaths = this.knownPropertyPaths;\n\t\tthis.unknownPropertyPaths = {};\n\t\tthis.knownPropertyPaths = {};\n\t}\n\tvar error = this.validateAll(data, schema.not, null, null, dataPointerPath);\n\tvar notErrors = this.errors.slice(oldErrorCount);\n\tthis.errors = this.errors.slice(0, oldErrorCount);\n\tif (this.trackUnknownProperties) {\n\t\tthis.unknownPropertyPaths = oldUnknownPropertyPaths;\n\t\tthis.knownPropertyPaths = oldKnownPropertyPaths;\n\t}\n\tif (error === null && notErrors.length === 0) {\n\t\treturn this.createError(ErrorCodes.NOT_PASSED, {}, \"\", \"/not\");\n\t}\n\treturn null;\n};\n\n// parseURI() and resolveUrl() are from https://gist.github.com/1088850\n//   -  released as public domain by author (\"Yaffle\") - see comments on gist\n\nfunction parseURI(url) {\n\tvar m = String(url).replace(/^\\s+|\\s+$/g, '').match(/^([^:\\/?#]+:)?(\\/\\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\\/?#]*)(?::(\\d*))?))?([^?#]*)(\\?[^#]*)?(#[\\s\\S]*)?/);\n\t// authority = '//' + user + ':' + pass '@' + hostname + ':' port\n\treturn (m ? {\n\t\thref     : m[0] || '',\n\t\tprotocol : m[1] || '',\n\t\tauthority: m[2] || '',\n\t\thost     : m[3] || '',\n\t\thostname : m[4] || '',\n\t\tport     : m[5] || '',\n\t\tpathname : m[6] || '',\n\t\tsearch   : m[7] || '',\n\t\thash     : m[8] || ''\n\t} : null);\n}\n\nfunction resolveUrl(base, href) {// RFC 3986\n\n\tfunction removeDotSegments(input) {\n\t\tvar output = [];\n\t\tinput.replace(/^(\\.\\.?(\\/|$))+/, '')\n\t\t\t.replace(/\\/(\\.(\\/|$))+/g, '/')\n\t\t\t.replace(/\\/\\.\\.$/, '/../')\n\t\t\t.replace(/\\/?[^\\/]*/g, function (p) {\n\t\t\t\tif (p === '/..') {\n\t\t\t\t\toutput.pop();\n\t\t\t\t} else {\n\t\t\t\t\toutput.push(p);\n\t\t\t\t}\n\t\t});\n\t\treturn output.join('').replace(/^\\//, input.charAt(0) === '/' ? '/' : '');\n\t}\n\n\thref = parseURI(href || '');\n\tbase = parseURI(base || '');\n\n\treturn !href || !base ? null : (href.protocol || base.protocol) +\n\t\t(href.protocol || href.authority ? href.authority : base.authority) +\n\t\tremoveDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : (href.pathname ? ((base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname) : base.pathname)) +\n\t\t(href.protocol || href.authority || href.pathname ? href.search : (href.search || base.search)) +\n\t\thref.hash;\n}\n\nfunction getDocumentUri(uri) {\n\treturn uri.split('#')[0];\n}\nfunction normSchema(schema, baseUri) {\n\tif (baseUri === undefined) {\n\t\tbaseUri = schema.id;\n\t} else if (typeof schema.id === \"string\") {\n\t\tbaseUri = resolveUrl(baseUri, schema.id);\n\t\tschema.id = baseUri;\n\t}\n\tif (typeof schema === \"object\") {\n\t\tif (Array.isArray(schema)) {\n\t\t\tfor (var i = 0; i < schema.length; i++) {\n\t\t\t\tnormSchema(schema[i], baseUri);\n\t\t\t}\n\t\t} else if (typeof schema['$ref'] === \"string\") {\n\t\t\tschema['$ref'] = resolveUrl(baseUri, schema['$ref']);\n\t\t} else {\n\t\t\tfor (var key in schema) {\n\t\t\t\tif (key !== \"enum\") {\n\t\t\t\t\tnormSchema(schema[key], baseUri);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvar ErrorCodes = {\n\tINVALID_TYPE: 0,\n\tENUM_MISMATCH: 1,\n\tANY_OF_MISSING: 10,\n\tONE_OF_MISSING: 11,\n\tONE_OF_MULTIPLE: 12,\n\tNOT_PASSED: 13,\n\t// Numeric errors\n\tNUMBER_MULTIPLE_OF: 100,\n\tNUMBER_MINIMUM: 101,\n\tNUMBER_MINIMUM_EXCLUSIVE: 102,\n\tNUMBER_MAXIMUM: 103,\n\tNUMBER_MAXIMUM_EXCLUSIVE: 104,\n\t// String errors\n\tSTRING_LENGTH_SHORT: 200,\n\tSTRING_LENGTH_LONG: 201,\n\tSTRING_PATTERN: 202,\n\t// Object errors\n\tOBJECT_PROPERTIES_MINIMUM: 300,\n\tOBJECT_PROPERTIES_MAXIMUM: 301,\n\tOBJECT_REQUIRED: 302,\n\tOBJECT_ADDITIONAL_PROPERTIES: 303,\n\tOBJECT_DEPENDENCY_KEY: 304,\n\t// Array errors\n\tARRAY_LENGTH_SHORT: 400,\n\tARRAY_LENGTH_LONG: 401,\n\tARRAY_UNIQUE: 402,\n\tARRAY_ADDITIONAL_ITEMS: 403,\n\t// Format errors\n\tFORMAT_CUSTOM: 500,\n\t// Schema structure\n\tCIRCULAR_REFERENCE: 500,\n\t// Non-standard validation options\n\tUNKNOWN_PROPERTY: 1000\n};\nvar ErrorMessagesDefault = {\n\tINVALID_TYPE: \"invalid type: {type} (expected {expected})\",\n\tENUM_MISMATCH: \"No enum match for: {value}\",\n\tANY_OF_MISSING: \"Data does not match any schemas from \\\"anyOf\\\"\",\n\tONE_OF_MISSING: \"Data does not match any schemas from \\\"oneOf\\\"\",\n\tONE_OF_MULTIPLE: \"Data is valid against more than one schema from \\\"oneOf\\\": indices {index1} and {index2}\",\n\tNOT_PASSED: \"Data matches schema from \\\"not\\\"\",\n\t// Numeric errors\n\tNUMBER_MULTIPLE_OF: \"Value {value} is not a multiple of {multipleOf}\",\n\tNUMBER_MINIMUM: \"Value {value} is less than minimum {minimum}\",\n\tNUMBER_MINIMUM_EXCLUSIVE: \"Value {value} is equal to exclusive minimum {minimum}\",\n\tNUMBER_MAXIMUM: \"Value {value} is greater than maximum {maximum}\",\n\tNUMBER_MAXIMUM_EXCLUSIVE: \"Value {value} is equal to exclusive maximum {maximum}\",\n\t// String errors\n\tSTRING_LENGTH_SHORT: \"String is too short ({length} chars), minimum {minimum}\",\n\tSTRING_LENGTH_LONG: \"String is too long ({length} chars), maximum {maximum}\",\n\tSTRING_PATTERN: \"String does not match pattern: {pattern}\",\n\t// Object errors\n\tOBJECT_PROPERTIES_MINIMUM: \"Too few properties defined ({propertyCount}), minimum {minimum}\",\n\tOBJECT_PROPERTIES_MAXIMUM: \"Too many properties defined ({propertyCount}), maximum {maximum}\",\n\tOBJECT_REQUIRED: \"Missing required property: {key}\",\n\tOBJECT_ADDITIONAL_PROPERTIES: \"Additional properties not allowed\",\n\tOBJECT_DEPENDENCY_KEY: \"Dependency failed - key must exist: {missing} (due to key: {key})\",\n\t// Array errors\n\tARRAY_LENGTH_SHORT: \"Array is too short ({length}), minimum {minimum}\",\n\tARRAY_LENGTH_LONG: \"Array is too long ({length}), maximum {maximum}\",\n\tARRAY_UNIQUE: \"Array items are not unique (indices {match1} and {match2})\",\n\tARRAY_ADDITIONAL_ITEMS: \"Additional items not allowed\",\n\t// Format errors\n\tFORMAT_CUSTOM: \"Format validation failed ({message})\",\n\t// Schema structure\n\tCIRCULAR_REFERENCE: \"Circular $refs: {urls}\",\n\t// Non-standard validation options\n\tUNKNOWN_PROPERTY: \"Unknown property (not in schema)\"\n};\n\nfunction ValidationError(code, message, dataPath, schemaPath, subErrors) {\n\tif (code === undefined) {\n\t\tthrow new Error (\"No code supplied for error: \"+ message);\n\t}\n\tthis.code = code;\n\tthis.message = message;\n\tthis.dataPath = dataPath || \"\";\n\tthis.schemaPath = schemaPath || \"\";\n\tthis.subErrors = subErrors || null;\n}\nValidationError.prototype = new Error();\nValidationError.prototype.prefixWith = function (dataPrefix, schemaPrefix) {\n\tif (dataPrefix !== null) {\n\t\tdataPrefix = dataPrefix.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n\t\tthis.dataPath = \"/\" + dataPrefix + this.dataPath;\n\t}\n\tif (schemaPrefix !== null) {\n\t\tschemaPrefix = schemaPrefix.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n\t\tthis.schemaPath = \"/\" + schemaPrefix + this.schemaPath;\n\t}\n\tif (this.subErrors !== null) {\n\t\tfor (var i = 0; i < this.subErrors.length; i++) {\n\t\t\tthis.subErrors[i].prefixWith(dataPrefix, schemaPrefix);\n\t\t}\n\t}\n\treturn this;\n};\n\nfunction isTrustedUrl(baseUrl, testUrl) {\n\tif(testUrl.substring(0, baseUrl.length) === baseUrl){\n\t\tvar remainder = testUrl.substring(baseUrl.length);\n\t\tif ((testUrl.length > 0 && testUrl.charAt(baseUrl.length - 1) === \"/\")\n\t\t\t|| remainder.charAt(0) === \"#\"\n\t\t\t|| remainder.charAt(0) === \"?\") {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvar languages = {};\nfunction createApi(language) {\n\tvar globalContext = new ValidatorContext();\n\tvar currentLanguage = language || 'en';\n\tvar api = {\n\t\taddFormat: function () {\n\t\t\tglobalContext.addFormat.apply(globalContext, arguments);\n\t\t},\n\t\tlanguage: function (code) {\n\t\t\tif (!code) {\n\t\t\t\treturn currentLanguage;\n\t\t\t}\n\t\t\tif (!languages[code]) {\n\t\t\t\tcode = code.split('-')[0]; // fall back to base language\n\t\t\t}\n\t\t\tif (languages[code]) {\n\t\t\t\tcurrentLanguage = code;\n\t\t\t\treturn code; // so you can tell if fall-back has happened\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\taddLanguage: function (code, messageMap) {\n\t\t\tvar key;\n\t\t\tfor (key in ErrorCodes) {\n\t\t\t\tif (messageMap[key] && !messageMap[ErrorCodes[key]]) {\n\t\t\t\t\tmessageMap[ErrorCodes[key]] = messageMap[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar rootCode = code.split('-')[0];\n\t\t\tif (!languages[rootCode]) { // use for base language if not yet defined\n\t\t\t\tlanguages[code] = messageMap;\n\t\t\t\tlanguages[rootCode] = messageMap;\n\t\t\t} else {\n\t\t\t\tlanguages[code] = Object.create(languages[rootCode]);\n\t\t\t\tfor (key in messageMap) {\n\t\t\t\t\tif (typeof languages[rootCode][key] === 'undefined') {\n\t\t\t\t\t\tlanguages[rootCode][key] = messageMap[key];\n\t\t\t\t\t}\n\t\t\t\t\tlanguages[code][key] = messageMap[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tfreshApi: function (language) {\n\t\t\tvar result = createApi();\n\t\t\tif (language) {\n\t\t\t\tresult.language(language);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\tvalidate: function (data, schema, checkRecursive, banUnknownProperties) {\n\t\t\tvar context = new ValidatorContext(globalContext, false, languages[currentLanguage], checkRecursive, banUnknownProperties);\n\t\t\tif (typeof schema === \"string\") {\n\t\t\t\tschema = {\"$ref\": schema};\n\t\t\t}\n\t\t\tcontext.addSchema(\"\", schema);\n\t\t\tvar error = context.validateAll(data, schema, null, null, \"\");\n\t\t\tif (!error && banUnknownProperties) {\n\t\t\t\terror = context.banUnknownProperties();\n\t\t\t}\n\t\t\tthis.error = error;\n\t\t\tthis.missing = context.missing;\n\t\t\tthis.valid = (error === null);\n\t\t\treturn this.valid;\n\t\t},\n\t\tvalidateResult: function () {\n\t\t\tvar result = {};\n\t\t\tthis.validate.apply(result, arguments);\n\t\t\treturn result;\n\t\t},\n\t\tvalidateMultiple: function (data, schema, checkRecursive, banUnknownProperties) {\n\t\t\tvar context = new ValidatorContext(globalContext, true, languages[currentLanguage], checkRecursive, banUnknownProperties);\n\t\t\tif (typeof schema === \"string\") {\n\t\t\t\tschema = {\"$ref\": schema};\n\t\t\t}\n\t\t\tcontext.addSchema(\"\", schema);\n\t\t\tcontext.validateAll(data, schema, null, null, \"\");\n\t\t\tif (banUnknownProperties) {\n\t\t\t\tcontext.banUnknownProperties();\n\t\t\t}\n\t\t\tvar result = {};\n\t\t\tresult.errors = context.errors;\n\t\t\tresult.missing = context.missing;\n\t\t\tresult.valid = (result.errors.length === 0);\n\t\t\treturn result;\n\t\t},\n\t\taddSchema: function () {\n\t\t\treturn globalContext.addSchema.apply(globalContext, arguments);\n\t\t},\n\t\tgetSchema: function () {\n\t\t\treturn globalContext.getSchema.apply(globalContext, arguments);\n\t\t},\n\t\tgetSchemaMap: function () {\n\t\t\treturn globalContext.getSchemaMap.apply(globalContext, arguments);\n\t\t},\n\t\tgetSchemaUris: function () {\n\t\t\treturn globalContext.getSchemaUris.apply(globalContext, arguments);\n\t\t},\n\t\tgetMissingUris: function () {\n\t\t\treturn globalContext.getMissingUris.apply(globalContext, arguments);\n\t\t},\n\t\tdropSchemas: function () {\n\t\t\tglobalContext.dropSchemas.apply(globalContext, arguments);\n\t\t},\n\t\treset: function () {\n\t\t\tglobalContext.reset();\n\t\t\tthis.error = null;\n\t\t\tthis.missing = [];\n\t\t\tthis.valid = true;\n\t\t},\n\t\tmissing: [],\n\t\terror: null,\n\t\tvalid: true,\n\t\tnormSchema: normSchema,\n\t\tresolveUrl: resolveUrl,\n\t\tgetDocumentUri: getDocumentUri,\n\t\terrorCodes: ErrorCodes\n\t};\n\treturn api;\n}\n\nvar tv4 = createApi();\ntv4.addLanguage('en-gb', ErrorMessagesDefault);\n\n//legacy property\ntv4.tv4 = tv4;\n\nif (typeof module !== 'undefined' && module.exports){\n\tmodule.exports = tv4;\n}\nelse {\n\tglobal.tv4 = tv4;\n}\n\n})(this);\n\n//@ sourceMappingURL=tv4.js.map//@ sourceURL=tv4/tv4.js"
));
require.alias("tv4/tv4.js", "tv4/index.js");

